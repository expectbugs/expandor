# Expandor Phase 2 Implementation Checklist

## CRITICAL: How to Use This Checklist
- [ ] **SAVE YOUR PROGRESS**: After each major section, note the last completed checkbox number
- [ ] **IF INTERRUPTED**: Search for "RESUME:" to find where you left off
- [ ] **IF ERROR OCCURS**: Check "RECOVERY:" sections for that step
- [ ] **VALIDATION IS MANDATORY**: Never skip validation steps marked with ✓
- [ ] **DEPENDENCIES MATTER**: Follow the exact order - later files depend on earlier ones

## Pre-Start Verification
- [ ] 1. Verify Phase 1 is complete: `git log --oneline -1` shows Phase 1 commit
- [ ] 2. Verify virtual environment is activated: `which python` shows venv path
- [ ] 3. Verify all Phase 1 imports work: `python -c "from expandor import Expandor"`
- [ ] 4. Have expandor2.1.md, expandor2.2.md, expandor2.3.md open and ready
- [ ] 5. Current directory is expandor root: `pwd` → ________________
- [ ] 6. Create temp directories: `mkdir -p temp/{progressive,upscale,tiles}`

## Section 1: Prepare Existing Components

### Step 1.1: Move Misplaced Files
- [ ] 7. Move processors: `mv processors/*.py expandor/processors/`
- [ ] 8. Move result.py: `mv core/result.py expandor/core/`
- [ ] 9. ✓ VALIDATE: `ls expandor/processors/` shows quality_validator.py and seam_repair.py
- [ ] 10. ✓ VALIDATE: `ls expandor/core/result.py` exists

### Step 1.2: Exception Updates FIRST
- [ ] 11. Update `expandor/core/exceptions.py` to add complete UpscalerError class:
  ```python
  class UpscalerError(ExpandorError):
      """Upscaler tool execution errors"""
      def __init__(self, message: str, tool_name: Optional[str] = None, 
                   exit_code: Optional[int] = None):
          self.tool_name = tool_name
          self.exit_code = exit_code
          super().__init__(message, stage="upscaling")
  ```
- [ ] 12. ✓ VALIDATE: Check VRAMError has `operation` parameter in __init__
- [ ] 13. ✓ VALIDATE: `python -c "from expandor.core.exceptions import UpscalerError"` works

### Step 1.3: Update VRAMManager
- [ ] 14. Edit `expandor/core/vram_manager.py` to update calculate_generation_vram signature:
  - Add `dtype: str = "float16"` parameter after model_type
  - Replace line 36 with:
    ```python
    # Dtype mapping for different precision modes
    dtype_map = {"float16": 2, "float32": 4, "bfloat16": 2}
    bytes_per_pixel = dtype_map.get(dtype, 2)  # Default to float16
    ```
- [ ] 15. Add new methods to VRAMManager:
  - Add instance variable in __init__: `self.peak_usage_mb = 0.0`
  - `track_peak_usage(self, current_mb: float)`: 
    ```python
    self.peak_usage_mb = max(self.peak_usage_mb, current_mb)
    ```
  - `clear_cache(self)`:
    ```python
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
    ```
  - `get_peak_usage(self) -> float`: 
    ```python
    return self.peak_usage_mb
    ```
- [ ] 16. ✓ VALIDATE: `python -c "from expandor.core.vram_manager import VRAMManager; v = VRAMManager(); v.track_peak_usage(100)"`

**CHECKPOINT A**: Base components ready. No import errors should occur.

## Section 2: Supporting Utilities (No Dependencies)

### Step 2.1: Logging Utils
- [ ] 17. Create `expandor/utils/logging_utils.py` with ColoredFormatter
- [ ] 18. ✓ VALIDATE: Check imports include `logging`, `datetime`, and color codes
- [ ] 19. ✓ VALIDATE: Has `setup_logger` function that returns configured logger

### Step 2.2: Config Loader
- [ ] 20. Create `expandor/utils/config_loader.py` with ConfigLoader class
- [ ] 21. **CRITICAL**: Add fallback for missing pkg_resources:
  ```python
  try:
      import pkg_resources
      HAS_PKG_RESOURCES = True
  except ImportError:
      HAS_PKG_RESOURCES = False
  ```
- [ ] 22. Implement `get_config_path` with fallback:
  ```python
  def get_config_path(self, filename: str) -> Path:
      if HAS_PKG_RESOURCES:
          try:
              return Path(pkg_resources.resource_filename('expandor', f'config/{filename}'))
          except Exception:
              pass
      # Fallback to relative path
      return Path(__file__).parent.parent / 'config' / filename
  ```
- [ ] 23. ✓ VALIDATE: `load_yaml` returns empty dict for missing files, not exceptions
- [ ] 24. ✓ VALIDATE: Has default presets if YAML files missing

### Step 2.3: Result Updates
- [ ] 25. Verify `expandor/core/result.py` has StageResult and ExpandorResult
- [ ] 26. Add import: `from PIL import Image` if missing
- [ ] 27. ✓ VALIDATE: `python -c "from expandor.core.result import StageResult, ExpandorResult"`

**RECOVERY: If imports fail, check __init__.py files and PYTHONPATH**

## Section 3: Tracking Components (Independent)

### Step 3.1: Metadata Tracker
- [ ] 28. Create `expandor/core/metadata_tracker.py` as specified
- [ ] 29. ✓ VALIDATE: Has methods: `track_operation`, `record_event`, `add_stage`, `get_summary`
- [ ] 30. ✓ VALIDATE: `start_operation` returns operation_id string

### Step 3.2: Boundary Tracker
- [ ] 31. Create `expandor/core/boundary_tracker.py` with BoundaryTracker class
- [ ] 32. ✓ VALIDATE: `add_progressive_boundary` adds dict with position/direction/step
- [ ] 33. ✓ VALIDATE: `get_critical_boundaries` returns dict format:
  ```python
  {"horizontal": [x1, x2...], "vertical": [y1, y2...]}
  ```
- [ ] 34. ✓ VALIDATE: `get_boundary_regions(width, height, padding=10)` returns list of (x1,y1,x2,y2) tuples

### Step 3.3: Quality Validator (Already exists)
- [ ] 35. Verify `expandor/processors/quality_validator.py` exists and is valid
- [ ] 36. ✓ VALIDATE: Has `validate_expansion_quality` method
- [ ] 37. ✓ VALIDATE: Returns dict with 'passed', 'issues', 'score' keys

### Step 3.4: Seam Repair (Already exists)
- [ ] 38. Verify `expandor/processors/seam_repair.py` exists and is valid
- [ ] 39. ✓ VALIDATE: Has `repair_seams` method accepting image_path and mask
- [ ] 40. ✓ VALIDATE: Returns repaired image path

**CHECKPOINT B**: All tracking/processing components ready.

## Section 4: Update Base Strategy (Critical Order!)

### Step 4.1: Base Strategy Updates
- [ ] 41. Update `expandor/strategies/base_strategy.py`:
  - Change execute signature to: `execute(self, config, context: Optional[Dict[str, Any]] = None)`
  - Add pipeline attributes: `inpaint_pipeline`, `refiner_pipeline`, `img2img_pipeline`
  - Add tracker attributes: `metadata_tracker`, `boundary_tracker`
- [ ] 42. Add new methods:
  - `check_vram(self, required_mb: float) -> bool`
  - `save_stage(self, name: str, image_path: Path, metadata: Dict)`
  - `cleanup(self)`
- [ ] 43. Add import: `from ..core.result import StageResult`
- [ ] 44. ✓ VALIDATE: No import errors when importing BaseExpansionStrategy
- [ ] 45. ✓ VALIDATE: execute method accepts optional context parameter

## Section 5: Implement Strategies

### Step 5.1: Direct Upscale Strategy
- [ ] 46. Create `expandor/strategies/direct_upscale.py`
- [ ] 47. **CRITICAL**: Add import at top: `from ..core.exceptions import UpscalerError`
- [ ] 48. **FIX**: Change line 351 `_run_upscaler` to `_run_realesrgan`
- [ ] 49. ✓ VALIDATE: Imports include `subprocess`, `shutil`, `tempfile`
- [ ] 50. ✓ VALIDATE: Has `_calculate_upscale_passes` method
- [ ] 51. ✓ VALIDATE: Raises `UpscalerError` with tool_name and exit_code

### Step 5.2: Update Progressive Outpaint
- [ ] 52. Update `expandor/strategies/progressive_outpaint.py`:
  - Update execute signature to accept context parameter
  - Add: `from typing import Optional, Union, Dict, Any`
  - Store context: `self._context = context` if provided
- [ ] 53. ✓ VALIDATE: execute handles both Path and PIL.Image for source_image
- [ ] 54. ✓ VALIDATE: Boundary tracking calls use boundary_tracker from context

### Step 5.3: Tiled Expansion Strategy
- [ ] 55. Create `expandor/strategies/tiled_expansion.py`
- [ ] 56. Ensure execute signature matches: `execute(self, config, context: Optional[Dict[str, Any]] = None)`
- [ ] 57. ✓ VALIDATE: `_calculate_tiles` returns list of tile coordinates
- [ ] 61. ✓ VALIDATE: `_blend_tiles` uses gaussian weights for overlap regions
- [ ] 62. ✓ VALIDATE: Supports all three pipeline types with proper fallbacks

### Step 5.4: Strategy Factory
- [ ] 63. Update `expandor/strategies/__init__.py`:
  ```python
  STRATEGY_REGISTRY = {
      "direct_upscale": "direct_upscale.DirectUpscaleStrategy",
      "progressive_outpaint": "progressive_outpaint.ProgressiveOutpaintStrategy", 
      "tiled_expansion": "tiled_expansion.TiledExpansionStrategy",
      "swpo": "swpo_strategy.SlidingWindowStrategy",
      "cpu_offload": "cpu_offload.CPUOffloadStrategy",
      "hybrid_adaptive": "experimental.hybrid_adaptive.HybridAdaptiveStrategy"
  }
  ```
- [ ] 64. Add `get_strategy_class` function using importlib
- [ ] 65. ✓ VALIDATE: `python -c "from expandor.strategies import get_strategy_class, STRATEGY_REGISTRY"`
- [ ] 65a. ✓ VALIDATE: All STRATEGY_REGISTRY paths are importable:
  ```python
  for name, path in STRATEGY_REGISTRY.items():
      cls = get_strategy_class(name)
      print(f"{name}: {cls.__name__}")
  ```

### Step 5.5: Placeholder Strategies
- [ ] 66. Create `expandor/strategies/swpo_strategy.py` with SlidingWindowStrategy placeholder:
  ```python
  """Placeholder for Phase 3 SWPO implementation.
  See expandor3.1.md for full Sliding Window Progressive Outpainting."""
  ```
- [ ] 67. Create `expandor/strategies/cpu_offload.py` with CPUOffloadStrategy placeholder:
  ```python
  """Placeholder for Phase 3 CPU offload implementation.
  See expandor3.1.md for full CPU memory management strategy."""
  ```
- [ ] 68. Create `expandor/strategies/experimental/hybrid_adaptive.py` with HybridAdaptiveStrategy:
  ```python
  """Placeholder for Phase 3 hybrid adaptive implementation.
  See expandor3.1.md for full adaptive strategy selection."""
  ```
- [ ] 69. ✓ VALIDATE: All accept context parameter in execute method

**CHECKPOINT C**: All strategies implemented. Ready for core components.

## Section 6: Core Components (Depends on Strategies)

### Step 6.1: Strategy Selector
- [ ] 70. Create `expandor/core/strategy_selector.py`
- [ ] 71. **CRITICAL**: Use `_load_strategy_class` method name (NOT _lazy_load_strategy)
- [ ] 72. **CRITICAL**: NO direct strategy imports - use importlib only
- [ ] 73. ✓ VALIDATE: `select_strategy` returns tuple: (strategy_name, reason, metrics)
- [ ] 74. ✓ VALIDATE: Successfully loads a strategy class dynamically

### Step 6.2: Pipeline Orchestrator
- [ ] 75. Create `expandor/core/pipeline_orchestrator.py`
- [ ] 76. **CRITICAL**: Import strategies inside methods, not at module level
- [ ] 77. Ensure `_prepare_strategy` sets:
  - Pipelines on strategy instance
  - Trackers in context dict
  - Logger on strategy
- [ ] 78. ✓ VALIDATE: `_build_fallback_chain` returns ordered list of strategies
- [ ] 79. ✓ VALIDATE: Error handling preserves partial results

### Step 6.3: Main Expandor Class
- [ ] 80. Replace `expandor/core/expandor.py` with full implementation
- [ ] 81. **CRITICAL**: Add ConfigLoader with fallback handling
- [ ] 82. ✓ VALIDATE: `_validate_config` checks all required fields
- [ ] 83. ✓ VALIDATE: `_execute_expansion` properly orchestrates pipeline
- [ ] 84. ✓ VALIDATE: `_save_metadata` creates valid JSON files
- [ ] 85. ✓ VALIDATE: Handles both Path and PIL.Image source inputs

**CHECKPOINT D**: Core implementation complete.

## Section 7: Final Integration

### Step 7.1: Update Package Exports
- [ ] 86. Update `expandor/__init__.py`:
  - Export ExpandorResult, StageResult
  - Export VRAMError, StrategyError, QualityError
- [ ] 87. ✓ VALIDATE: `from expandor import ExpandorResult, StageResult`

### Step 7.2: Verify Configuration
- [ ] 88. Test YAML loading: `python -c "from expandor.utils.config_loader import ConfigLoader; c = ConfigLoader(); c.load_quality_preset('ultra')"`
- [ ] 89. ✓ VALIDATE: No errors loading any YAML file
- [ ] 90. ✓ VALIDATE: STRATEGY_REGISTRY has all 6 strategies

## Section 8: Testing

### Step 8.1: Test Infrastructure
- [ ] 91. Create `tests/conftest.py` with fixtures:
  - `test_image_paths` - returns dict of test images
  - `mock_pipelines` - returns configured mock pipelines
  - `temp_dir` - yields temporary directory
- [ ] 92. ✓ VALIDATE: `pytest --fixtures` shows all custom fixtures

### Step 8.2: Unit Tests
- [ ] 93. Create/update unit tests:
  - `tests/unit/test_vram_manager.py` (add dtype tests)
  - `tests/unit/test_strategy_selector.py`
  - `tests/unit/test_metadata_tracker.py`
  - `tests/unit/test_boundary_tracker.py`
  - `tests/unit/test_pipeline_orchestrator.py`
- [ ] 94. Create strategy tests in `tests/unit/` directory:
  - `tests/unit/test_direct_upscale_strategy.py`
  - `tests/unit/test_progressive_outpaint_strategy.py`
  - `tests/unit/test_tiled_expansion_strategy.py`
- [ ] 95. ✓ VALIDATE: Each test file is runnable

### Step 8.3: Integration Tests
- [ ] 96. Create `tests/integration/test_expandor_integration.py`
- [ ] 97. Include tests for:
  - Complete workflow (config → result)
  - Error scenarios with recovery
  - Strategy fallback chains
  - Quality validation
- [ ] 98. ✓ VALIDATE: Uses context properly in all tests

### Step 8.4: Test Scripts
- [ ] 99. Create `run_tests.sh`:
  ```bash
  #!/bin/bash
  source venv/bin/activate
  pytest tests/unit -v
  pytest tests/integration -v
  ```
- [ ] 100. Make executable: `chmod +x run_tests.sh`
- [ ] 101. Create `Makefile` with targets: test, test-unit, test-integration, lint, format

## Section 9: Final Validation

### Run Tests
- [ ] 102. Run all unit tests: `pytest tests/unit -v`
- [ ] 103. Run integration tests: `pytest tests/integration -v`
- [ ] 104. Note failures and warnings: _______________________

### Verify Functionality
- [ ] 105. Test complete import chain:
  ```python
  from expandor import Expandor, ExpandorConfig, ExpandorResult
  from expandor.core.strategy_selector import StrategySelector
  from expandor.strategies import get_strategy_class
  e = Expandor()
  print("Success!")
  ```
- [ ] 106. Test strategy loading:
  ```python
  from expandor.strategies import get_strategy_class
  cls = get_strategy_class("progressive_outpaint")
  print(f"Loaded: {cls.__name__}")
  ```

### Code Quality
- [ ] 107. Run linter: `flake8 expandor --max-line-length=120 --ignore=E501`
- [ ] 108. Format code: `black expandor tests`

### Git Commit
- [ ] 109. Stage changes: `git add -A`
- [ ] 110. Commit: `git commit -m "Phase 2: Core implementation with basic strategies complete"`
- [ ] 111. ✓ VALIDATE: `git log --oneline -2` shows both commits

## COMPLETION CRITERIA
- [ ] All 112 checkboxes marked (including 65a)
- [ ] Core functionality works without import errors
- [ ] Strategies load dynamically
- [ ] Context parameter handled properly
- [ ] At least 70% of tests pass
- [ ] No critical linting errors

## CRITICAL PATH ITEMS
These MUST be correct or Phase 2 will fail:
1. UpscalerError defined BEFORE DirectUpscaleStrategy
2. execute() accepts optional context parameter
3. _load_strategy_class (not _lazy_load_strategy)
4. _run_realesrgan (not _run_upscaler)
5. STRATEGY_REGISTRY uses dot notation for modules
6. No direct strategy imports in core modules
7. VRAMManager accepts dtype parameter
8. ConfigLoader handles missing pkg_resources

## RECOVERY PROCEDURES

### Import Errors
1. Check PYTHONPATH: `export PYTHONPATH=$PYTHONPATH:$(pwd)`
2. Verify __init__.py: `find expandor -type d -exec touch {}/__init__.py \;`
3. Fix circular imports:
   - Move import inside method: `def execute(): from x import Y`
   - Use TYPE_CHECKING: `if TYPE_CHECKING: from x import Y; else: Y = "x.Y"`
   - Use string refs in registries: `"module.Class"` not `Class`
4. Fix relative imports: `from ..core.exceptions` not `from core.exceptions`

### Strategy Loading Fails
1. Verify STRATEGY_REGISTRY paths are correct
2. Check strategy class names match
3. Ensure context parameter in execute
4. Verify BaseExpansionStrategy inheritance

### YAML Loading Errors
1. Check pkg_resources availability
2. Use os.path fallback if needed
3. Verify YAML syntax is valid
4. Ensure file paths are correct

### Test Failures
1. Mock pipelines configured: 
   ```python
   mock_pipeline = MockInpaintPipeline()
   config.inpaint_pipeline = mock_pipeline
   ```
2. Context dict has required keys:
   ```python
   context = {
       'metadata_tracker': MetadataTracker(),
       'boundary_tracker': BoundaryTracker(),
       'logger': logging.getLogger(__name__)
   }
   ```
3. Temp directories: `mkdir -p temp/{progressive,upscale,tiles}`
4. Fixtures exist: `ls tests/fixtures/*.png` shows 4 test images

**Phase 2 Complete!** Proceed to expandor3.1.md only after ALL items checked.